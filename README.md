# Vault Engine SDK Docuemtation

By integrating with Vault Engine, devlopers can effecivly introduce a plug and play backend to your application, largly side stepping responsibility of devloping, managing, and maintaining many of the essential backend features critical to blockchain dapp devlopment. A more percise overview of features is avaliable and why you should consider Vault Engine for you DAPP checkout vaultwallet.io/VaultEngineSDK


## Getting Started

These instructions will get you give you the resources needed to integrate Vault Engine into your product design roadmap, as well as begin devlopment. 

### ~Installing~ **Need actual bash/cmd install steps**Exculude from production
-None yet

## Usage in React Native - Exculude from production
### Import the module(s)
```
import Vault from 'vault-wrapper';
import { DeviceEventEmitter } from 'react-native';
```
### Vault Engine Primitive Concepts
#### User Accounts 
A user account is created using a unique identifer generated by some kind of authentication mechanism, here oAUTH. You can think of a user account as the parent to all other data. On the Vault Engine Server a user account is used to associate public keys with human readable names, allowing seamless crpyto user experiences. Additionally it is reccomended that a recover neumonic is generated to be assoicated with the user account. By doing this future private key pairs (Key Accounts) will be recoverable easily by the end user. When a user account is deleted from a device, the sdk deletes all local information assoicated with that user account, such as private/public keys, cached transaction information, etc. 

#### Key Accounts 
Within the Vault Engine SDK key accounts are the name for a public + private key pair and the associated metadata included along with them. Conceptually, you can think of this as a child object of a User Account, because each key account is assoicated with a User. 
**`WalletAccount` is an object representing the `publicAddress`, `type` and `nickname`**

#### Shared Accounts
A shared account is type of key account in which the public key is publically avaliable to other app users via a 'connection'. Unlike a default key account, this type of account, and its assoicated stored coins, will be both visable to your connections; as well as the endpoint which others will transact to. For example if two users were to wish to transact using Shared Accounts, each person would see and trasact to each other persons shared account (think abstracted public key). 
**`SharedAccount` is an object representing the `public address`, `type`, `isMyAccount`, `nickname`and `userId`** -- All the accounts you share to others and the accounts shared to you
#### Connections
Connections can be thought of as 'friends'. Using this feature of the SDK allows abstraction of public keys and surfacing of simple human readable account names associated defintivly with users. Akin to social features, connections can be sent, recieved, accepted, and denied. A master list of all connection names (users) is stored in the Vault Engine cloud backend so each instance can query a live list.  

### User Accounts and Authentication
#### Add/Update Account
Need more details onwhat the account is. Like is this the account that you AUTH into locally, or the 'account' used on the cloud to identify the user? What is jwt, where is userId initalized/come from? On the backend what actions does this call peform for the 'account'? does it generate the wallet for the account etc? 
```
vault.addAccount(jwt, userId, name, email)
```
#### Remove Account
Delete a user account an all associated data from the local device. This includes private keys.
@Raul What arguments does this take? 
```
vault.removeAccount()
```
#### Check Account Exists
Check if a account exists on the local device. 
@Raul Details on arugment is needed
```
VaultWallet.hasAccount(cb)
```
### Key Account and Key Accout Managment
#### Get all Key Accounts
Retrieve a list of wallet key accounts associated with the current user account.
```
VaultWallet.getWalletAccounts((walletAccounts) => {
  console.log(walletAccounts)
})
```
### Get Key Account for KeyAlias
Key accounts have an associated allias locally. You can pull for these key alias 

```
val walletAccount = vault.getWalletAccount(keyAlias)
```
#### Observing **my** Wallet Key Accounts
To setup a listenter for one of your wallets, so that you can recieve notifcations of changes in wallet activity, use the following call. 
```
DeviceEventEmitter.addListener('WalletAccounts')
```
#### Delete/Stop tracking the account
Delete a key account from the current user. This deletes the private key locally as well as all meta data associated with this key account. 
```
vault.deleteAccount(walletAccount)
```
### Shared Accounts
#### Share a key account with user
Expose a current account as a shared account to a specified user on the service. 
```
vault.shareAccount(userId, walletAccount)
```
#### Unshare an key account with user
Remove visibility of a shared account from a specified user on the service. 
```
vault.unshareAccount(userId, walletAccount)
````
#### Get all shared key accounts relationships
Retrieve a list of all of the currently shared key accounts assoicated with the current user? 
@Raul Some details on the context of this call? Does it take param for a user, is there some user state? 
```
var sharedAccounts = vault.getSharedAccounts()
```
#### Observing shared accounts
Place a listener on a shared account such that you will be notified when there is activity changes in that account. 
@Raul Params needed? Is this all accounts? 
```
vault.startObservingSharedAccounts(callback)
...
vault.stopObservingSharedAccounts(callback)
```
### Connections and Connection Management
#### Get all connections
Retrieve a list of the current (accepted) connections associated with the current user. 
```
var connections = vault.getConnections()
```
### Start/Stop Observing connections changes
Place a listener on connections. For example, I wish to know when another user x has accepted my connection request. 
```
vault.startObservingConnections(walletAccounts, callback)
...
vault.stopObservingConnections(callback)
```
#### Find a connection
Query the vault wallet server for a particular user based on the searchQuery string. 
```
vault.findConnection(searchQuery, callbackWithIds)
```
#### Add a connection
Add a connection to your local connection list and send a connection request to the corrosponding user (think friend request). 
```
vault.addConnection(searchResultId)
```
#### Accept a connection request
Accept a currently pending connection request
```
vault.acceptConnectionRequest(userIdOrSearchResultId)
```
#### Decline a connection request
Decline a currently pending connection request
```
vault.declineConnectionRequest(userIdOrSearchResultId)
```
#### Get a pending connection request
Get a list of all currently pending connection requests
```
var pendingRequests = vault.getPendingRequests()
```
#### Start/Stop Observing Pending Connection Requests
Listen for state changes on currently pending connection requests. 
```
vault.startObservingConnectionsRequests(callback)
...
vault.stopObservingConnectionRequests(callback)
```
### Mnemonic
Mnemonic's allow users to recover their private keys with a backup seed they have saved. Each user account should have a mnemonic associated with it so that wallets can be generated with them. It is considered best pratice to do this at the UX level faily soon after user account creation. 
#### Generate a seed (word size can be 16, 20, 24, 28 or 32)
```
var generatedMnemonicSeed = vault.generateSeed(wordSize)
```
#### Import from seed (or generate). 
*This will register the `WalletAccount` automatically with the backend. The key alias can be public -- no need to treat it like a password.*
```
var keyAlias = vault.importMnemonic(menmonicString, addressIndex = 0)
```
#### Get Public Address of a Mnemonic
*CryptoObject is used in conjunction with the SE/TEE to validate user biometric authentication ~(optional)~.*
*We are decomposing the key alias which has the public address of address 0 of the mnemonic*
```
val publicAddress = vault.getPublicAddress(mnemonicString, addressIndex = 0)
// OR
val publicAddress = vault.getPublicAddress(keyAlias, addressIndex = 0, cryptoObject?)
```
#### Show Mnemonic
```
vault.showMnemonic(keyAlias, cryptoObject?, callback)
```
#### Cloud backup - Keep or leave? 
```
vault.cloudBackup(keyAlias, cryptoObject?, callback)
```
#### Import cloud backup - Keep or leave? 
```
vault.importCloud()
```
#### Generate Another wallet from a mnemonic
Generate a key account which is recoverable with the user accounts stored mnemonic
```
var publicAddress = vault.createWallet(keyAlias, nameOfWallet, addressIndex = 0, cryptoObject?)
// OR
var publicAddress = vault.createWallet(mnemonicString, nameOfWallet, addressIndex = 0, cryptoObject?)
```

### Get Transactions for Specific Key Accounts
```
var transactions = vault.getTransactions(walletAccounts)
```
### Observing Transactions on Specfic Key Accounts
```
vault.startObservingTransactions(walletAccounts, callback)
...
vault.stopObservingTransactions(callback)
```
### Send Transaction
Sign and send a transaction to the blockchain
> * accountFromKeyAlias - 
> * toAddress - 
> * value - 
> * cryptoObject? - 
```
vault.postTransaction(accountFromkeyAlias, toAddress, value, cyrptoObject?, callback)
```

### Realtime Connectivity Status
#### Get current connected state
If you need to check if the wallet is currently connected to the blockchain through Vault Wallets backend servers use the following call. 

```
VaultWallet.isConnected(
  (connected) => {
    console.log("Connected: " + connected)
  }
);
```
#### Observing connected state
Listener will notify if the Wallet is connected or disconnected to the internet. 
```
DeviceEventEmitter.addListener('connectionChange', function(e: Event) {
    console.log("Connected: " + e.connected)
})
```

## Authors

* **Rahul Behera** - *Initial work* - [Vault Wallet](https://github.com/thebehera)
* **Rahul Behera** - *Version_2* - [Vault Wallet](https://github.com/gondee)

See also the list of [contributors](https://github.com/your/project/contributors) who participated in this project.

## License

This project is licensed under the [TBD] License - see the [LICENSE.md](LICENSE.md) file for details
